<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  vaadin.elements.grid.HierarchyBehavior = {

    observers: [
      '_columnsChangedHierarchy(columns)'
    ],

    properties: {
      _hierarchyColumn: {
        value: function() {
          return document.createElement('vaadin-grid-hierarchy-column');
        }
      }
    },

    _columnsChangedHierarchy: function() {
      if (this.columns.indexOf(this._hierarchyColumn.$.column) === -1) {
        this.unshift('columns', this._hierarchyColumn.$.column);
      }
    }

  };
</script>

<dom-module id="vaadin-grid-hierarchy-column">
  <template>
    <style>
      .hierarchy-button {
        border: 7px solid transparent;
        border-left-width: 12px;
        border-left-color: #000;
        cursor: pointer;
        display: inline-block;
        vertical-align: middle;
        transition: transform 0.2s;
        transform-origin: 25%;
      }

      .hierarchy-button[opened] {
        transform: rotateZ(90deg);
      }
    </style>
    <vaadin-grid-column id="column" width="[[_getColumnWidth()]]px" flex="0">
      <template>
        <div>
          <span on-click="_toggleOpened" index="[[index]]" class="hierarchy-button" style="margin-left: [[_getPadding(index, _foo)]]px" opened$="[[_isHierarchyExpanded(index, _foo)]]"></span>
          <span>[[index]]</span>
        </div>
      </template>
    </vaadin-grid-column>
  </template>
  <script>
    Polymer({
      is: 'vaadin-grid-hierarchy-column',

      observer: ['_hierarchyExpandedChanged(_hierarchyExpanded.splices)'],

      properties: {
        _hierarchyExpanded: {
          value: []
        },

        // TODO: Replace with actual itemproperty
        _foo: {
          value: 0
        }
      },

      ready: function() {
        // this.tree = this.$.column.grid.tree;
      },

      _getColumnWidth: function() {
        return this._getMaxHierarchyLevel() * 10 + 100;
      },

      _getPadding: function(index) {
        return this._getItemHierarchyLevel(index) * 10;
      },

      // TODO: Base API's on items?
      // TODO: Implement
      _getItemHierarchyLevel: function(index) {
        return this.$.column.grid && this.$.column.grid.tree.getNestingLevel(index);
      },

      // TODO: Implement
      _getMaxHierarchyLevel: function() {
        return 4;
      },

      // TODO: Implement
      _isHierarchyExpanded: function(index) {
        return this.$.column.grid && this.$.column.grid.tree.getNestingLevel(index) === this.$.column.grid.tree.getNestingLevel(index + 1) - 1;
      },

      _hierarchyExpandedChanged: function(e) {

      },

      _toggleOpened: function (e) {
        var grid = this.$.column.grid;
        if (this._isHierarchyExpanded(e.model.index)) {
          console.log('remove');
          grid.tree.remove(e.model.index);
          grid._updateItems();
        } else {
          grid.tree.add(e.model.index, 5);
          grid.tree.loadItem(6, grid.dataSource, function() {
            grid._updateItems();
          }); //temp hack
        }
        // grid.clearCache();
        // grid._updateItems();
        this._foo++;
      }

    });
  </script>
</dom-module>
<script>
  (function() {
    window.TreeCache = function(parent, size) {
      this.parent = parent;
      this.size = size;
      this.pageSize = 50;
      this.trees = [];
      this.cache = {};
      this._pendingRequests = [];

      this.getItem = function(index) {
        var nested = this.getNestedTree(index);

        if (nested) {
          return nested.getItem(index - nested.parent - 1);
        } else {
          var page = Math.floor(index / this.pageSize);

          if (this.cache[page]) {
            return this.cache[page][index - page * this.pageSize];
          }
        }
      }.bind(this);

      this.getNestedTreeSizeBefore = function(index) {
        return this.trees.filter(function(tree) {
          return tree.parent < index;
        }).map(function(tree) {
          return tree.totalSize();
        }).reduce(function(curr, next) {
          return curr + next;
        }, 0);
      };

      this.getNestedTree = function(index) {
        var nested = this.trees.filter(function(tree) {
          return tree.parent < index && index <= (tree.parent + tree.totalSize());
        });

        return nested.length > 0 ? nested[0] : undefined;
      };

      this.getTree = function(index) {
        var nested = this.getNestedTree(index);

        return nested ? nested.getTree(index - nested.parent - 1) : this;
      };

      this.getNestingLevel = function(index) {
        var nested = this.getNestedTree(index);

        return nested ? (1 + nested.getNestingLevel(index - nested.parent - 1)) : 0;
      };

      this.getPage = function(index) {
        var nested = this.getNestedTree(index);

        if (nested) {
          return nested.getPage(index - nested.parent - 1);
        } else {
          return Math.floor(index / this.pageSize);
        }
      };

      this.loadItem = function(index, dataSource, callback) {
        var nested = this.getNestedTree(index);

        if (nested) {
          nested.loadItem(index - nested.parent - 1, dataSource, callback);
        } else {
          var page = this.getPage(index);
          if (this._pendingRequests.indexOf(page) === -1) {
            this._pendingRequests.push(page);
            var params =  {page: page, pageSize: this.pageSize, path: index + '-'};
            dataSource(params, function(items, size) {
              this._pendingRequests.splice(this._pendingRequests.indexOf(page), 1);
              this.cache[page] = items;
              // this.size = size; // TODO:
              callback(this.getItem(index));
            }.bind(this));
          }
        }
      };

      this.pendingRequests = function() {
        return this._pendingRequests.length + this.trees
          .map(function(tree) { return tree.pendingRequests(); })
          .reduce(function(curr, next) {
              return curr + next;
            }, 0);
      };
      //
      // this.loadPage = function(index) {
      //   var nested = this.getNestedTree(index);
      //
      //   if (nested) {
      //     this.loadPage(index - nested.parent - 1);
      //   } else {
      //     var page = this.getPage(index);
      //     var path = this.getPath(index);
      //
      //     this.dataSource(page, path etc.) {
      //       this.cache[page] = items;
      //       this.size = size;
      //
      //       // -> updateItems;
      //     };
      //   }
      // };

      this.getParentTree = function(index) {
        var trees = this.trees.filter(function(tree) {
          return tree.parent === index;
        });

        return trees.length > 0 ? trees[0] : undefined;
      };

      this.add = function(index, size) {
        var nested = this.getNestedTree(index);

        if (nested) {
          nested.add(index - nested.parent - 1, size);
        } else {
          var tree = this.getParentTree(index);

          if (tree) {
            tree.size = size;
          } else {
            var child = new TreeCache(index - this.getNestedTreeSizeBefore(index), size);
            this.trees.push(child);
          }
        }
      };

      this.remove = function(index) {
        var nestedTree = this.getParentTree(index);

        if (nestedTree) {
          this.trees.splice(this.trees.indexOf(nestedTree), 1);
        } else {
          // TODO: can be optimized later to iterate only trees that the index is
          // inside of.
          this.trees.forEach(function(tree) {
            tree.remove(index - tree.parent - 1);
          });
        }
      };

      this.totalSize = function() {
        return this.size + this.trees.reduce(function(curr, next) {
          return curr + next.totalSize();
        }, 0);
      };
    };
  })();
</script>
