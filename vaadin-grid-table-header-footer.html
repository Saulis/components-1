<script>
  (function() {
    var vaadinGridTableRowContainerBehavior = {
      properties: {
        columns: Array,
        frozenColumns: Number,
        _rows: Array
      },

      observers: ['_columnsChanged(columns.*, frozenColumns)', '_rowsChanged(_rows)'],

      _columnsChanged: function(e) {
        if (e.path === 'columns') {
          function getParent(groups, column) {
            for (var i = 0; i < groups.length; i++) {
              var grp = groups[i];
              children = Polymer.dom(grp).children.filter(function(e) {
                return e.tagName.toLowerCase() == 'vaadin-grid-column'
              });
              if (children.indexOf(column) >= 0) {
                grp.childs = children.length;
                return grp;
              }
            }
          }

          function fillMatrixColumns(groups, matrix, col, idx, row, type) {
            var tpls = col._templates(type);
            for (var i = 0; i <= row; i++) {
              var parent = i && !tpls[i] ? getParent(groups, col) : null;
              if (parent) {
                fillMatrixColumns(groups, matrix, parent, idx, row - i , type)
                return;
              }
              matrix[row - i] = matrix[row - i] || [];
              matrix[row - i][idx] = {
                column: col
              }
            }
          }

          function fillMatrixTemplates(matrix, idx, rows, type) {
            var last = null, tpls = [], j = 0;
            for (var row = 0; row <= rows; row++, j++) {
              var obj = matrix[row][idx];
              if (obj.column != last) {
                tpls = obj.column._templates(type);
                j = 0;
              }
              last = obj.column;
              obj.template = tpls[j];
              if (!obj.template && rows - row > 0)  {
                var next = matrix[row + 1][idx].column;
                if (next != obj.column) {
                  obj.column = next;
                  row --;
                }
              }
              if (idx > 0 && matrix[row][idx - 1].template == obj.template) {
                delete obj.template
              }
            }
          }

          function fillMatrixSpans(matrix, idx, rows) {
            for (var i = 0; i <= rows; i++) {
              var obj = matrix[i][idx];
              var col = obj.column;
              var tpl = obj.template;
              if (col && tpl) {
                var colspan = col.hasAttribute('colspan') && parseInt(col.getAttribute('colspan')) || 0;
                colspan += (col.childs || 1);
                var rowspan = 0;
                for (var j = i + 1; j <= rows; j++) {
                  var next = matrix[j][idx];
                  if (!next.template && next.column == col) {
                    rowspan ++;
                  }
                }
                obj.colspan = colspan;
                obj.rowspan = rowspan;
              }
            }
          }

          var groups = e.value.filter(function(col) {
            return !!Polymer.dom(col).querySelectorAll('vaadin-grid-column').length;
          });
          var columns = e.value.filter(function(col) {
            return !Polymer.dom(col).querySelectorAll('vaadin-grid-column').length;
          });

          var matrix = [];
          var nrows = this._rowCount(e.value) - 1;
          columns.forEach(function(col, idx) {
            lastCol = fillMatrixColumns(groups, matrix, col, idx, nrows, this.type);
          }.bind(this));
          columns.forEach(function(unused, idx) {
            fillMatrixTemplates(matrix, idx, nrows, this.type);
          }.bind(this));
          columns.forEach(function(unused, idx) {
            fillMatrixSpans(matrix, idx, nrows);
          }.bind(this));

          // LOG
          // matrix.forEach(function(cols, row) {
          //   cols.forEach(function(obj, idx){
          //     console.log(row, obj.column.getAttribute('mcm'), obj.colspan, obj.rowspan, obj.template);
          //   }.bind(this));
          // }.bind(this))

          this._rows = matrix.map(function(objects, index) {
            var row = this._createRow();
            row.rowIndex = index;
            row.frozenColumns = this.frozenColumns;
            row._objectsChanged(objects, index);
            row.target = this.domHost.domHost;
            return row;
          }.bind(this));

        } else if (e.path.indexOf('columns.#') === 0) {
          this._rows.forEach(function(row) {
            row.notifyPath(e.path, e.value);
          });
        }
      },

      _rowsChanged: function(rows) {
        Polymer.dom(this).innerHTML = '';

        rows.forEach(function(row) {
          Polymer.dom(this).appendChild(row);
        }.bind(this));
      },

      _rowCount: function(columns) {
        return Math.max.apply(Math, columns.map(function(c) {
          return c._rowCount(this.type);
        }));
      }
    };

    Polymer({
      is: 'vaadin-grid-table-header',
      extends: 'thead',
      behaviors: [vaadinGridTableRowContainerBehavior],
      type: 'header',

      _createRow: function() {
        return document.createElement('tr', 'vaadin-grid-table-header-row');
      }
    });

    Polymer({
      is: 'vaadin-grid-table-footer',
      extends: 'tfoot',
      behaviors: [vaadinGridTableRowContainerBehavior],
      type: 'footer',

      _createRow: function() {
        return document.createElement('tr', 'vaadin-grid-table-footer-row');
      }
    });
  })();
</script>
