<script>
  (function() {

    /**
     * Creates a Matrix that configures headers or footers.
     * Each element in the matrix represents a cell with the following structure:
     *  {
     *     column: the original <vaadin-grid-column> element
     *     template: the template associated with the cell
     *     colspan: the horizontal size in number of cells that covers.
     *     rowspan: the vertical size in rows covered.
     *     width: the value configured in the column (or the sum of all columns covered)
     *     display: 'none' when the cell is spanned by another one
     *  }
     */
    var vaadinGridMatrixBehavior = {
      properties: {
        matrix: {
          type: Object
        },
        nrows: 0,
        ncols: 0
      },

      _configureMatrix: function(groupsAndColumns) {
        // Remove groups
        var dataColumns = groupsAndColumns.filter(function(col) {
          return !Polymer.dom(col).querySelectorAll('vaadin-grid-column').length;
        });

        this.ncols = dataColumns.length;
        this.nrows = this._rowCount(groupsAndColumns);
        this.matrix = [];

        // Adding dataColumns, parent groups will be computed and added based on them.
        dataColumns.forEach(function(column, idx) {
          this._addColumnToMatrix(column, idx, this.nrows - 1)
        }.bind(this));

        this._setMatrixTemplates();

        this._computeMatrixSizes();
      },

      // Adds a column in the matrix.
      //   idx: is the position of the column
      //   rows: is the max number of rows. Note that this is called
      //         recursively so rows is being decreased each interaction.
      _addColumnToMatrix: function(col, idx, rows) {
        var tpls = col._templates(this.type);
        // Each element of the matrix has a column o a group
        for (var i = 0; i <= rows; i++) {
          var parent = i && !tpls[i] ? col._group() : null;
          if (parent) {
            this._addColumnToMatrix(parent, idx, rows - i);
            return;
          }
          this.matrix[rows - i] = this.matrix[rows - i] || [];
          this.matrix[rows - i][idx] = {
            column: col
          }
        }
      },

      // Visit all matrix elements, and sets the appropriate template.
      //  Supports multiple templates perl column/group (TODO: remove ?)
      //  Cells without template means blank cells
      _setMatrixTemplates: function() {
        for (var idx = 0; idx < this.ncols; idx++) {
          for (var row = 0, j = 0, tpls = [], last; row < this.nrows; row++, j++) {
            var obj = this.matrix[row][idx];

            // We support multiple templates per group and column (TODO: remove ?)
            if (obj.column != last) {
              tpls = obj.column._templates(this.type);
              j = 0;
            }
            last = obj.column;
            obj.template = tpls[j];

            if (!obj.template && row + 1 < this.nrows)  {
              var next = this.matrix[row + 1][idx].column;
              // move up one level the column, if column doesn't have a template for this level
              if (next != obj.column) {
                obj.column = next;
                row--;
              }
            } else {
              for (var i = idx - 1; i >= 0; i--) {
                // Remove duplicate templates
                if (this.matrix[row][i].template == obj.template) {
                  delete obj.template;
                }
              }
            }
          }
        }
        // Remove empty rows: none of its elements has template.
        for (var row = this.nrows - 1; row >= 0; row--) {
          var valid = this.matrix[row].filter(function(o){
            return !!o.template;
          })
          if (valid.length == 0) {
            this.matrix.splice(row, 1);
          }
        }
        this.nrows = this.matrix.length;
      },

      // Visit all matrix elements, and compute colspan, rowspan, width and display
      _computeMatrixSizes() {
        for (var idx = 0; idx < this.ncols; idx++) {
          for (var i = 0; i < this.nrows; i++) {
            var obj = this.matrix[i][idx];
            var col = obj.column;
            var tpl = obj.template;

            // group/column knows how to compute its width and flex based on children
            obj.width = col._colWidth();
            obj.colspan = col._colCount();

            // Code supporting user colspan. TODO: remove ?
            var userColspan = col.hasAttribute('colspan') && parseInt(col.getAttribute('colspan')) || 0;
            if (userColspan > obj.colspan) {
              for (var j = 1; j <= (userColspan - obj.colspan) && idx + j < this.ncols; j++) {
                obj.width += ' + ' + this.matrix[i][idx + j].column._colWidth();
              }
              obj.colspan = userColspan;
            }

            // Compute rowspan. It doesn't do anything so far because we use flex layouts
            if (col && tpl) {
              var rowspan = 0;
              for (var j = i + 1; j < this.nrows; j++) {
                var next = this.matrix[j][idx];
                if (!next.template && next.column == col) {
                  rowspan ++;
                }
              }
              obj.rowspan = rowspan;
            }

            // Hide all cells that are covered by colspanned cells
            for (var j = 1; !obj.display && j < obj.colspan && idx + j < this.ncols; j++) {
              this.matrix[i][idx + j].display = 'none';
            }
          }
        }
      }
    };

    var vaadinGridTableRowContainerBehavior = {
      properties: {
        columns: Array,
        frozenColumns: Number,
        _rows: Array
      },

      observers: ['_columnsChanged(columns.*, frozenColumns)', '_rowsChanged(_rows)'],

      _columnsChanged: function(e) {
        if (e.path === 'columns') {
          this._configureMatrix(e.value);

          this._rows = this.matrix.map(function(objects, index) {
            var row = this._createRow();
            row.rowIndex = index;
            row.frozenColumns = this.frozenColumns;
            row._objectsChanged(objects, index);
            row.target = this.domHost.domHost;
            return row;
          }.bind(this));

        } else if (e.path.indexOf('columns.#') === 0) {
          // TODO: handle this case, it does not work.
          this._rows.forEach(function(row) {
            row.notifyPath(e.path, e.value);
          });
        }
      },

      _rowsChanged: function(rows) {
        Polymer.dom(this).innerHTML = '';

        rows.forEach(function(row) {
          Polymer.dom(this).appendChild(row);
        }.bind(this));
      },

      _rowCount: function(columns) {
        return Math.max.apply(Math, columns.map(function(c) {
          return c._rowCount(this.type);
        }.bind(this)));
      }
    };

    Polymer({
      is: 'vaadin-grid-table-header',
      extends: 'thead',
      behaviors: [vaadinGridMatrixBehavior, vaadinGridTableRowContainerBehavior],
      type: 'header',

      _createRow: function() {
        return document.createElement('tr', 'vaadin-grid-table-header-row');
      }
    });

    Polymer({
      is: 'vaadin-grid-table-footer',
      extends: 'tfoot',
      behaviors: [vaadinGridMatrixBehavior, vaadinGridTableRowContainerBehavior],
      type: 'footer',

      _createRow: function() {
        return document.createElement('tr', 'vaadin-grid-table-footer-row');
      }
    });
  })();
</script>
