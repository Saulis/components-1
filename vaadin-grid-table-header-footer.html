<script>
  (function() {

    /**
     * Creates a Matrix that represent All headers and footers.
     * Each element in the matrix reptesents a cell and has the structure:
     *  {
     *     column: the original <vaadin-grid-column> element
     *     template: the template associated with the cell
     *     colspan: the horizontal size in number of cells that covers.
     *     rowspan: the vertical size in rows covered.
     *     width: the value configured in the column (or the sum of all columns covered)
     *     display: 'none' when the cell is spanned by another one
     *  }
     */
    var vaadinGridMatrixBehavior = {
      properties: {
        matrix: null,
        dataColumns: null,
        nrows: 0
      },

      _configureMatrix: function(groupsAndColumns) {
        // Remove groups
        this.dataColumns = groupsAndColumns.filter(function(col) {
          return !Polymer.dom(col).querySelectorAll('vaadin-grid-column').length;
        });

        this.nrows = this._rowCount(groupsAndColumns) - 1;
        this.ncols = this.dataColumns.length;
        this.matrix = [];

        this.dataColumns.forEach(function(column, idx) {
          this._addColumnToMatrix(column, idx, this.nrows)
        }.bind(this));

        this._setMatrixTemplates();

        this._computeMatrixSizes();
      },

      // Adds a column in the matrix.
      //   idx: is the position of the column
      //   rows: is the max number of rows. Note that this is called
      //         recursively so rows is being decreased each interaction.
      _addColumnToMatrix: function(col, idx, rows) {
        var tpls = col._templates(this.type);
        for (var i = 0; i <= rows; i++) {
          var parent = i && !tpls[i] ? col._group() : null;
          if (parent) {
            this._addColumnToMatrix(parent, idx, rows - i);
            return;
          }
          this.matrix[rows - i] = this.matrix[rows - i] || [];
          this.matrix[rows - i][idx] = {
            column: col
          }
        }
      },

      // Visit all matrix elements, and sets the appropriate template.
      //  Supports multiple templates perl column/group (TODO: remove support for that)
      //  Cells without template means blank cells
      _setMatrixTemplates: function() {
        for (var idx = 0; idx < this.ncols; idx++) {
          var last = null, tpls = [], j = 0;
          for (var row = 0; row <= this.nrows; row++, j++) {
            var obj = this.matrix[row][idx];
            if (obj.column != last) {
              tpls = obj.column._templates(this.type);
              j = 0;
            }
            last = obj.column;
            obj.template = tpls[j];
            if (!obj.template && this.nrows - row > 0)  {
              var next = this.matrix[row + 1][idx].column;
              if (next != obj.column) {
                obj.column = next;
                row--;
              }
            } else {
              for (var i = idx - 1; i >= 0; i--) {
                if (this.matrix[row][i].template == obj.template) {
                  delete obj.template;
                }
              }
            }
          }
        }
      },

      // Visit all matrix elements, and compute colspan, rowspan, width and display
      _computeMatrixSizes() {
        for (var idx = 0; idx < this.ncols; idx++) {
          var rows = this.matrix.length - 1;
          var cols = this.matrix[0] && this.matrix[0].length ||Â 0;
          for (var i = 0; i <= rows; i++) {
            var obj = this.matrix[i][idx];
            var col = obj.column;
            var tpl = obj.template;
            obj.colspan = col.hasAttribute('colspan') && parseInt(col.getAttribute('colspan')) || 0;
            obj.colspan += col._colCount();
            obj.width = col._colWidth();
            if (col && tpl) {
              var rowspan = 0;
              for (var j = i + 1; j <= rows; j++) {
                var next = this.matrix[j][idx];
                if (!next.template && next.column == col) {
                  rowspan ++;
                }
              }
              obj.rowspan = rowspan;
            }
            for (var j = 1; !obj.display && j < obj.colspan && idx + j < cols; j++) {
              this.matrix[i][idx + j].display = 'none';
            }
          }
        }
      }
    };

    var vaadinGridTableRowContainerBehavior = {
      properties: {
        columns: Array,
        frozenColumns: Number,
        _rows: Array
      },

      observers: ['_columnsChanged(columns.*, frozenColumns)', '_rowsChanged(_rows)'],

      _columnsChanged: function(e) {
        if (e.path === 'columns') {
          this._configureMatrix(e.value);

          this._rows = this.matrix.map(function(objects, index) {
            var row = this._createRow();
            row.rowIndex = index;
            row.frozenColumns = this.frozenColumns;
            row._objectsChanged(objects, index);
            row.target = this.domHost.domHost;
            return row;
          }.bind(this));

        } else if (e.path.indexOf('columns.#') === 0) {
          this._rows.forEach(function(row) {
            row.notifyPath(e.path, e.value);
          });
        }
      },

      _rowsChanged: function(rows) {
        Polymer.dom(this).innerHTML = '';

        rows.forEach(function(row) {
          Polymer.dom(this).appendChild(row);
        }.bind(this));
      },

      _rowCount: function(columns) {
        return Math.max.apply(Math, columns.map(function(c) {
          return c._rowCount(this.type);
        }.bind(this)));
      }
    };

    Polymer({
      is: 'vaadin-grid-table-header',
      extends: 'thead',
      behaviors: [vaadinGridMatrixBehavior, vaadinGridTableRowContainerBehavior],
      type: 'header',

      _createRow: function() {
        return document.createElement('tr', 'vaadin-grid-table-header-row');
      }
    });

    Polymer({
      is: 'vaadin-grid-table-footer',
      extends: 'tfoot',
      behaviors: [vaadinGridMatrixBehavior, vaadinGridTableRowContainerBehavior],
      type: 'footer',

      _createRow: function() {
        return document.createElement('tr', 'vaadin-grid-table-footer-row');
      }
    });
  })();
</script>
